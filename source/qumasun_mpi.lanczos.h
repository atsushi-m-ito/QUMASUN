#pragma once
//#define _USE_MATH_DEFINES
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include "qumasun_mpi.h"
#include "lanczos_z.h"
#include "msz.complex.h"
#include "vecmath.h"
#if 0
#include "initial_Arnoldi_d.h"

//Generate Initial State by Arnoldi method(Krylov subspace)
inline
void QUMASUN_MPI::mInitStateArnoldi() {


	const uint32_t seed = 123456789;
	//WrapdSFMT dsfmt(seed, std::min<int>(N, 10000));	//状態保持.
	std::mt19937 mt(seed);
	std::normal_distribution<> distribution(0.0, 1.0);

	const double dVol = m_dx * m_dy * m_dz;

	int gen_count = 0;
	while (gen_count < num_solution) {


		//initialize//
		{
			double* x = ml_psi[gen_count];
			const size_t local_size = ml_grid.Size3D();
			double l_norm = 0.0;
			for (size_t i = 0; i < local_size; ++i) {
				x[i] = distribution(mt);
				l_norm += x[i] * x[i];
			}
			double sum_norm = 0.0;
			MPI_Allreduce(&l_norm, &sum_norm, 1, MPI_DOUBLE, MPI_SUM, ml_grid.mpi_comm);

			sum_norm = 1.0 / std::sqrt(sum_norm * dVol);
			for (size_t i = 0; i < local_size; ++i) {
				x[i] *= sum_norm;
			}
		}

		gen_count += InitializeByArnoldy_d(ml_grid, dVol, num_solution - gen_count,
			std::max((num_solution - gen_count)*1000, num_solution),
			ml_psi[gen_count],
			[this](double* Ax, double* x) {
				this->mHamiltonianMatrix_ddm(Ax, this->ml_Vtot, x);
			});
	}

	printf("Initial %d states were generated by Arnoldi method\n", gen_count);
}
#endif


//Solve the Kohn-Sham equation by Lanczos method////////////////
inline
void QUMASUN_MPI::mSolveLanczos() {


#if 1
	printf("Lanczos solver is not yet supported in Real field(not complex field)\n");
#else
	EigenLanczos_z(m_size_3d, num_solution, num_solusion_Lanczos,
		m_eigen_values, m_psi_buffer.Pointer(),
		[this, &V](dcomplex* Ax, dcomplex* x) {
			RspaceFunc<dcomplex> refAx(Ax);
			RspaceFunc<dcomplex> refx(x);
			this->mHamiltonianMatrix(refAx, V, refx);
		});
#endif

}

inline
void QUMASUN_MPI::mCheckEigenVector() {
#if 0
	using namespace msz::complex;
	RspaceFunc<double>& V = m_Vtot;

	for (int s = 0; s < num_solution; ++s) {
		if (is_root) {
			RspaceFunc<double>& p = m_psi_set[s];
			RspaceFunc<double>& Hp = m_work_rd;

			mHamiltonianMatrix(Hp, V, p);

			{
				const double norm_Hp = vecmath::Norm<double>(Hp, m_size_3d);
				const double norm_p = vecmath::Norm<double>(p, m_size_3d);
				const double in = vecmath::InnerProd<double>(p, Hp, m_size_3d);

				printf("(%d) norm(p), norm(Hp), cos = %f, %f, (%f)\n", s, norm_p, norm_Hp, in / sqrt(norm_Hp * norm_p));

			}
		} else {
			mHamiltonianMatrix(m_work_rd, m_work_rd, m_work_rd);
		}
	}
#endif
	
}
