#ifdef USE_MPI
#pragma once
#include <mpi.h>
#include "mpi_helper.h"
#include "wrap_lapack.h"
#include "w_dsygvx.h"
#include "w_dgemm.h"
#include "GridRange.h"
#include "GridScatterGather.h"

#include "vecmath.h"
#include "inverse_m.h"
#include "print_matrix.h"

//ScaLapack does not support communicator generated by MPI_Comm_split
#ifdef USE_SCALAPACK
#include "w_pdsygvx.h"
#endif

//#define DEBUG_PRINT_ON
#include "debug_print.h"

//LOBPCG法で複数の固有ベクトルを求める//

//対角化を手動でせずに、小行列の一般化固有値解法に任せた方が良い//
//なぜなら、(1)matrix Aの演算が1回/iterationで済む。//

//dVolを乗じずに内積を取って1になるように関数の入り口でxをscaleする//
//出口でxを逆scaleして大きさを戻す//
//pはスケール後のものが関数から出力される//


#define USE_BLAS
//#ifdef _NEC
//#define SELF_TRANSPOSE
//#endif
//#define USE_SPLIT_LAPACK

//#define OPERATION_BUNDLE

//XR, RP of S-matrix is directly calculated from Cx,Cr,Cp. But accuracy is low., and then convergence has problem.
#define DIRECT_S_MATRIX_XR_RP

//S行列を次のステップでも使いまわす場合//
//安定しないのでしばらくpending//
//#define S_MATRIX_RELOAD

//数値誤差が発生時にrollbackとescapeをする実装(must)
#define CHECK_NEXT_VECTOR


//#define DEBUG_PRINT_MATRIX
//#define LOBPCG_DEBUG_PRINT

//#define LOBPCG_D_PRINT_EIGEN
//#define LOBPCG_D_PRINT_NORM



namespace LOBPCG{

    constexpr inline double LIMIT_D_NORM_X_FOR_RESET_MATRIX = 1.0e-3;

inline
int MakeMatrix_d(int local_size, int num_solution, double* Sa, double* Sb,
	const std::vector<double*>& x, const std::vector<double*>& r, const std::vector<double*>& p,
	const std::vector<double*>& Ax, const std::vector<double*>& Ar, const std::vector<double*>& Ap) {

	using namespace vecmath;

	const int n3 = num_solution * 3;
	for (int j = 0; j < num_solution; ++j) {
		for (int k = 0; k < num_solution; ++k) {

			Sa[j * n3 + k] = InnerProd(x[k], Ax[j], local_size);
			Sa[j * n3 + k + num_solution] = InnerProd(r[k], Ax[j], local_size);
			Sa[j * n3 + k + 2 * num_solution] = InnerProd(p[k], Ax[j], local_size);

			Sa[(j + num_solution) * n3 + k] = InnerProd(x[k], Ar[j], local_size);
			Sa[(j + num_solution) * n3 + k + num_solution] = InnerProd(r[k], Ar[j], local_size);
			Sa[(j + num_solution) * n3 + k + 2 * num_solution] = InnerProd(p[k], Ar[j], local_size);

			Sa[(j + 2 * num_solution) * n3 + k] = InnerProd(x[k], Ap[j], local_size);
			Sa[(j + 2 * num_solution) * n3 + k + num_solution] = InnerProd(r[k], Ap[j], local_size);
			Sa[(j + 2 * num_solution) * n3 + k + 2 * num_solution] = InnerProd(p[k], Ap[j], local_size);


			Sb[j * n3 + k] = InnerProd(x[k], x[j], local_size);
			Sb[j * n3 + k + num_solution] = InnerProd(r[k], x[j], local_size);
			Sb[j * n3 + k + 2 * num_solution] = InnerProd(p[k], x[j], local_size);

			Sb[(j + num_solution) * n3 + k] = InnerProd(x[k], r[j], local_size);
			Sb[(j + num_solution) * n3 + k + num_solution] = InnerProd(r[k], r[j], local_size);
			Sb[(j + num_solution) * n3 + k + 2 * num_solution] = InnerProd(p[k], r[j], local_size);

			Sb[(j + 2 * num_solution) * n3 + k] = InnerProd(x[k], p[j], local_size);
			Sb[(j + 2 * num_solution) * n3 + k + num_solution] = InnerProd(r[k], p[j], local_size);
			Sb[(j + 2 * num_solution) * n3 + k + 2 * num_solution] = InnerProd(p[k], p[j], local_size);


		}
	}
	int num_gemm_call = 18;
	return num_gemm_call;
}



#ifdef USE_BLAS


#ifdef SELF_TRANSPOSE
//for VE
inline
int MakeMatrix_d_blas(int local_size, int num_solution, double* Sa, double* Sb,
	const std::vector<double*>& x, const std::vector<double*>& r, const std::vector<double*>& p,
	const std::vector<double*>& Ax, const std::vector<double*>& Ar, const std::vector<double*>& Ap,
	double* tmpM,
	bool is_skip_x_p, bool is_skip_Ax_Ap, bool is_skip_xr_rp) {

	using namespace vecmath;

	DEBUG_PRINTF("Use BLAS in MakeMatrix_d(self transpose)\n");

	const int n3 = num_solution * 3;
	double* X_t = tmpM;
	transpose(local_size, num_solution, x[0], local_size, X_t, num_solution);

	if (!is_skip_Ax_Ap) {
		blas_DGEMM_n(num_solution, num_solution, local_size, X_t, Ax[0], Sa, n3, 1.0, 0.0);
	}
	blas_DGEMM_n(num_solution, num_solution, local_size, X_t, Ar[0], Sa + num_solution * n3, n3, 1.0, 0.0);
	if (!is_skip_Ax_Ap) {
		blas_DGEMM_n(num_solution, num_solution, local_size, X_t, Ap[0], Sa + num_solution * 2 * n3, n3, 1.0, 0.0);
	}

	if (!is_skip_x_p) {
		blas_DGEMM_n(num_solution, num_solution, local_size, X_t, x[0], Sb, n3, 1.0, 0.0);
	}
#ifdef DIRECT_S_MATRIX_XR_RP
	if (!is_skip_xr_rp) 
#endif
	{
		blas_DGEMM_n(num_solution, num_solution, local_size, X_t, r[0], Sb + num_solution * n3, n3, 1.0, 0.0);
	}
	if (!is_skip_x_p) {
		blas_DGEMM_n(num_solution, num_solution, local_size, X_t, p[0], Sb + num_solution * 2 * n3, n3, 1.0, 0.0);
	}

	double* R_t = X_t;
	transpose(local_size, num_solution, r[0], local_size, R_t, num_solution);

	blas_DGEMM_n(num_solution, num_solution, local_size, R_t, Ar[0], Sa + num_solution * (n3 + 1), n3, 1.0, 0.0);
	blas_DGEMM_n(num_solution, num_solution, local_size, R_t, Ap[0], Sa + num_solution * (2 * n3 + 1), n3, 1.0, 0.0);
	

	blas_DGEMM_n(num_solution, num_solution, local_size, R_t, r[0], Sb + num_solution * (n3 + 1), n3, 1.0, 0.0);
#ifdef DIRECT_S_MATRIX_XR_RP
	if (!is_skip_xr_rp) 
#endif
	{
		blas_DGEMM_n(num_solution, num_solution, local_size, R_t, p[0], Sb + num_solution * (2 * n3 + 1), n3, 1.0, 0.0);
	}

	double* P_t = X_t;
	transpose(local_size, num_solution, p[0], local_size, P_t, num_solution);

	if (!is_skip_Ax_Ap) {
		blas_DGEMM_n(num_solution, num_solution, local_size, P_t, Ap[0], Sa + num_solution * (2 * n3 + 2), n3, 1.0, 0.0);
	}

	if (!is_skip_x_p) {
		blas_DGEMM_n(num_solution, num_solution, local_size, P_t, p[0], Sb + num_solution * (2 * n3 + 2), n3, 1.0, 0.0);
	}

	

	//number of call of dgemm//
	int num_gemm_call = 18 - 6;//6 means lower triangle//
	if (is_skip_x_p) num_gemm_call -= 3;
	if (is_skip_Ax_Ap) num_gemm_call -= 3;
#ifdef DIRECT_S_MATRIX_XR_RP
	if (is_skip_xr_rp) num_gemm_call -= 2;
#endif
	return num_gemm_call;

}

#else
	//default transpose is calculated in BLAS//
inline
int MakeMatrix_d_blas(int local_size, int num_solution, double* Sa, double* Sb,
	const std::vector<double*>& x, const std::vector<double*>& r, const std::vector<double*>& p,
	const std::vector<double*>& Ax, const std::vector<double*>& Ar, const std::vector<double*>& Ap,
	bool is_skip_x_p, bool is_skip_Ax_Ap, bool is_skip_xr_rp) {

	using namespace vecmath;

	DEBUG_PRINTF("Use BLAS in MakeMatrix_d_mat\n");

	const int n3 = num_solution * 3;

	
	
	if (!is_skip_Ax_Ap) {
		blas_DGEMM_t(num_solution, num_solution, local_size, x[0], Ax[0], Sa, n3, 1.0, 0.0);
	}
	blas_DGEMM_t(num_solution, num_solution, local_size, x[0], Ar[0], Sa + num_solution * n3, n3, 1.0, 0.0);
	blas_DGEMM_t(num_solution, num_solution, local_size, r[0], Ar[0], Sa + num_solution * (n3 + 1), n3, 1.0, 0.0);
	if (!is_skip_Ax_Ap) {
		blas_DGEMM_t(num_solution, num_solution, local_size, x[0], Ap[0], Sa + num_solution * 2 * n3, n3, 1.0, 0.0);
	}
	blas_DGEMM_t(num_solution, num_solution, local_size, r[0], Ap[0], Sa + num_solution * (2 * n3 + 1), n3, 1.0, 0.0);
	if (!is_skip_Ax_Ap) {
		blas_DGEMM_t(num_solution, num_solution, local_size, p[0], Ap[0], Sa + num_solution * (2 * n3 + 2), n3, 1.0, 0.0);
	}
	

	if (!is_skip_x_p) {
		blas_DGEMM_t(num_solution, num_solution, local_size, x[0], x[0], Sb, n3, 1.0, 0.0);
	}
#ifdef DIRECT_S_MATRIX_XR_RP
	if (!is_skip_xr_rp) 
#endif
	{
		blas_DGEMM_t(num_solution, num_solution, local_size, x[0], r[0], Sb + num_solution * n3, n3, 1.0, 0.0);
	}
	blas_DGEMM_t(num_solution, num_solution, local_size, r[0], r[0], Sb + num_solution * (n3 + 1), n3, 1.0, 0.0);
	if (!is_skip_x_p) {
		blas_DGEMM_t(num_solution, num_solution, local_size, x[0], p[0], Sb + num_solution * 2 * n3, n3, 1.0, 0.0);
	}
#ifdef DIRECT_S_MATRIX_XR_RP
	if (!is_skip_xr_rp) 
#endif
	{
		blas_DGEMM_t(num_solution, num_solution, local_size, r[0], p[0], Sb + num_solution * (2 * n3 + 1), n3, 1.0, 0.0);
	}
	if (!is_skip_x_p) {
		blas_DGEMM_t(num_solution, num_solution, local_size, p[0], p[0], Sb + num_solution * (2 * n3 + 2), n3, 1.0, 0.0);
	}

	//number of call of dgemm//
	int num_gemm_call = 18 - 6; //6 means lower triangle
	if (is_skip_x_p) num_gemm_call -= 3;
	if (is_skip_Ax_Ap) num_gemm_call -= 3;
#ifdef DIRECT_S_MATRIX_XR_RP
	if(is_skip_xr_rp) num_gemm_call -= 2;
#endif
	return num_gemm_call;
}
#endif
#endif

inline
void CopySubMat(int Nx, int Ny, double* dest, int ldd, const double* src, int lds) {
	//column major//
	for (int ix = 0; ix < Nx; ++ix) {
		for (int iy = 0; iy < Ny; ++iy) {
			dest[iy + ldd * ix] = src[iy + lds * ix];
		}
	}
}

inline
int NextMatrix_d(int num_solution, double* Sa, double* Sb,
	const double* CxCrCp, const double* eigen_values, bool is_use_p, bool need_H_matrix) {

	using namespace vecmath;
	DEBUG_PRINTF("Use BLAS in MakeMatrix_d_mat\n");

	

	const int N = num_solution;
	const int n3 = N * 3;
	const int n2 = N * 2;
	const int nn = N * N;
	const int next = n3*n3*2;
	const double* Cx = CxCrCp;
	const double* Cr = CxCrCp + N;
	const double* Cp = CxCrCp + N * 2;
	const int stride_C = (is_use_p) ? num_solution * 3 : num_solution * 2;
	const int stride_S = num_solution * 3;



	{
		///for direct update (P^t P), (X^t P), (X^t X) /////////////////////////////////
		double* XtX = Sb;
		double* XtR = Sb + N * n3;
		double* XtP = Sb + N * 2 * n3;
		double* RtR = Sb + N * (n3 + 1);
		double* RtP = Sb + N * (2 * n3 + 1);
		double* PtP = Sb + N * (2 * n3 + 2);

		double* tmp1 = Sb + next;
		double* tmpPtP = Sb + next + nn;
		double* tmpXtP = Sb + next + nn * 2;
		double* tmpXtX = Sb + next + nn * 3;

		/*
		P'= R * Cr + P * Cp
		(P'^t P') = Cr^t [(R^t R) Cr + (R^t P) Cp] + Cp^t [(P^t R) Cr + (P^t P) Cp]
		*/
		//tmp1 = (R ^ t R) Cr
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, RtR, stride_S, Cr, stride_C, 0.0, tmp1, N);
		if (is_use_p) {
			//tmp1 += (R ^ t P) Cp
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, RtP, stride_S, Cp, stride_C, 1.0, tmp1, N);
		}
		//tmpPtP = Cr^t tmp1
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cr, stride_C, tmp1, N, 0.0, tmpPtP, N);

		if (is_use_p) {
			//tmp1 = (P ^ t R) Cr = (R ^ t P)^t Cr
			//tmp1 += (P ^ t P) Cp
			cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, RtP, stride_S, Cr, stride_C, 0.0, tmp1, N);
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, PtP, stride_S, Cp, stride_C, 1.0, tmp1, N);
			//tmpPtP += Cp^t tmp1
			cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cp, stride_C, tmp1, N, 1.0, tmpPtP, N);
		}


		//(X'^t P') = (P'^t P') + Cx^t [(X^t R) Cr + (X^t P) Cp]
		//tmp1 = (X^t R) Cr
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtR, stride_S, Cr, stride_C, 0.0, tmp1, N);
		if (is_use_p) {
			//tmp1 += (X^t P) Cp
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtP, stride_S, Cp, stride_C, 1.0, tmp1, N);
		}

		//tmpXtP = tmpPtP
		CopySubMat(N, N, tmpXtP, N, tmpPtP, N);
		//tmpXtP += Cx^t tmp1
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cx, stride_C, tmp1, N, 1.0, tmpXtP, N);

		//(X'^t X') = (X'^t P') + [(X^t X) Cx + (X^t R) Cr + (X^t P)Cp]^t Cx
		//here, tmp1 == (X^t R) Cr + (X^t P)Cp
		//tmp1 += (X^t X) Cx
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtX, stride_S, Cx, stride_C, 1.0, tmp1, N);
		//tmpXtX = tmpXtP
		CopySubMat(N, N, tmpXtX, N, tmpXtP, N);
		//tmpXtX += tmp1^t Cx
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, tmp1, N, Cx, stride_C, 1.0, tmpXtX, N);

		//P'^t P' = tmpPtP;
		CopySubMat(N, N, PtP, n3, tmpPtP, N);

		//X'^t P' = tmpXtP;
		CopySubMat(N, N, XtP, n3, tmpXtP, N);

		//X'^t X' = tmpXtX;
		CopySubMat(N, N, XtX, n3, tmpXtX, N);

	}
	
	int num_gemm_call = is_use_p ? 11:6;
	if (!need_H_matrix) return num_gemm_call;

	{
		///for direct update (P^t HP), (X^t HP), (X^t HX) /////////////////////////////////
		double* XtHX = Sa;
		double* XtHR = Sa + N * n3;
		double* XtHP = Sa + N * 2 * n3;
		double* RtHR = Sa + N * (n3 + 1);
		double* RtHP = Sa + N * (2 * n3 + 1);
		double* PtHP = Sa + N * (2 * n3 + 2);

		double* tmp1 = Sa + next;
		double* tmpPtHP = Sa + next + nn;
		double* tmpXtHP = Sa + next + nn * 2;
		double* tmpXtHX = Sa + next + nn * 3;

		/*
		P'= R * Cr + P * Cp
		(P'^t HP') = Cr^t [(R^t HR) Cr + (R^t HP) Cp] + Cp^t [(P^t HR) Cr + (P^t HP) Cp]
		*/
		//tmp1 = (R ^ t HR) Cr
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, RtHR, stride_S, Cr, stride_C, 0.0, tmp1, N);
		if (is_use_p) {
			//tmp1 += (R ^ t HP) Cp
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, RtHP, stride_S, Cp, stride_C, 1.0, tmp1, N);
		}
		//tmpPtHP = Cr^t tmp1
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cr, stride_C, tmp1, N, 0.0, tmpPtHP, N);

		if (is_use_p) {
			//tmp1 = (P ^ t HR) Cr = (R ^ t HP)^t Cr
			//tmp1 += (P ^ t HP) Cp
			cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, RtHP, stride_S, Cr, stride_C, 0.0, tmp1, N);
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, PtHP, stride_S, Cp, stride_C, 1.0, tmp1, N);
			//tmpPtHP += Cp^t tmp1
			cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cp, stride_C, tmp1, N, 1.0, tmpPtHP, N);
		}


		//(X'^t HP') = (P'^t HP') + Cx^t [(X^t HR) Cr + (X^t HP) Cp]
		//tmp1 = (X^t HR) Cr
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtHR, stride_S, Cr, stride_C, 0.0, tmp1, N);
		if (is_use_p) {
			//tmp1 += (X^t HP) Cp
			cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtHP, stride_S, Cp, stride_C, 1.0, tmp1, N);
		}

		//tmpXtHP = tmpPtHP
		CopySubMat(N, N, tmpXtHP, N, tmpPtHP, N);
		//tmpXtHP += Cx^t tmp1
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, Cx, stride_C, tmp1, N, 1.0, tmpXtHP, N);

		//(X'^t HX') = (X'^t HP') + [(X^t HX) Cx + (X^t HR) Cr + (X^t HP)Cp]^t Cx
		//here, tmp1 == (X^t HR) Cr + (X^t HP)Cp
		//tmp1 += (X^t HX) Cx
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, XtHX, stride_S, Cx, stride_C, 1.0, tmp1, N);
		//tmpXtHX = tmpXtP
		CopySubMat(N, N, tmpXtHX, N, tmpXtHP, N);
		//tmpXtHX += tmp1^t Cx
		cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans, N, N, N, 1.0, tmp1, N, Cx, stride_C, 1.0, tmpXtHX, N);

		//P'^t HP' = tmpPtHP;
		CopySubMat(N, N, PtHP, n3, tmpPtHP, N);

		//X'^t HP' = tmpXtHP;
		CopySubMat(N, N, XtHP, n3, tmpXtHP, N);

		//X'^t HX' = tmpXtHX;
		CopySubMat(N, N, XtHX, n3, tmpXtHX, N);
	}

#ifdef DIRECT_S_MATRIX_XR_RP
	{//direct update  (X^t R) and (R^t P)
		{
			//(X'^t R') = (X'^t H X') - (X'^t X')E'//
			double* XtR = Sb + N * n3;
			int ldm = n3;
			const double* tmpXtHX = Sa + next + nn * 3;
			const double* tmpXtX = Sb + next + nn * 3;
			for (int j = 0; j < N; ++j) {
				for (int i = 0; i < N; ++i) {
					XtR[i + ldm * j] = tmpXtHX[i + N * j] - tmpXtX[i + N * j] * eigen_values[j];
				}
			}
		}

		{
			//(R'^t P') = (X'^t H P') - E'(X'^t P')//
			double* RtP = Sb + N * (2 * n3 + 1);
			int ldm = n3;
			const double* tmpXtHP = Sa + next + nn * 2;
			const double* tmpXtP = Sb + next + nn * 2;
			for (int j = 0; j < N; ++j) {
				for (int i = 0; i < N; ++i) {
					RtP[i + ldm * j] = tmpXtHP[i + N * j] - eigen_values[i] * tmpXtP[i + N * j];
				}
			}
		}
	}
#endif

	num_gemm_call += is_use_p ? 11 : 6;
	return num_gemm_call;
}

void ScaleHSMatrix_d(int N, double* Sa, double* Sb, const double* sqrt_norms_x, const double* sqrt_norms_p, const double* sqrt_norms_r, bool need_H_matrix) {
	const int n3 = N * 3;
	const int ldd = n3;
	
	auto ScaleMatrix = [](int N, double* m, int ldm, const double* scale_i, const double* scale_j) {
		for (int j = 0; j < N; ++j) {
			for (int i = 0; i < N; ++i) {
				m[i + ldm * j] *= scale_i[i] * scale_j[j];
			}
		}
		};

	//for
	double* XtX = Sb;
	double* XtP = Sb + N * 2 * n3;
	double* PtP = Sb + N * (2 * n3 + 2);
	ScaleMatrix(N, PtP, ldd, sqrt_norms_p, sqrt_norms_p);
	ScaleMatrix(N, XtP, ldd, sqrt_norms_x, sqrt_norms_p);
	ScaleMatrix(N, XtX, ldd, sqrt_norms_x, sqrt_norms_x);

	if (!need_H_matrix) return;

	double* XtHX = Sa;
	double* XtHP = Sa + N * 2 * n3;
	double* PtHP = Sa + N * (2 * n3 + 2);
	ScaleMatrix(N, PtHP, ldd, sqrt_norms_p, sqrt_norms_p);
	ScaleMatrix(N, XtHP, ldd, sqrt_norms_x, sqrt_norms_p);
	ScaleMatrix(N, XtHX, ldd, sqrt_norms_x, sqrt_norms_x);

#ifdef DIRECT_S_MATRIX_XR_RP
	double* XtR = Sb + N * n3;
	double* RtP = Sb + N * (2 * n3 + 1);
	ScaleMatrix(N, XtR, ldd, sqrt_norms_x, sqrt_norms_x);
	ScaleMatrix(N, RtP, ldd, sqrt_norms_x, sqrt_norms_p);
#endif
}

inline 
void LoadSMatrix_d(int N, double* Sb, double* src) {
	const int n3 = N * 3;
	const int ldd = n3;

	double* XtX = Sb;
	double* XtP = Sb + N * 2 * n3;
	double* PtP = Sb + N * (2 * n3 + 2);
	CopySubMat(N, N, XtX, n3, src, N);
	CopySubMat(N, N, XtP, n3, src + N * N, N);
	CopySubMat(N, N, PtP, n3, src + N * N * 2, N);
	
}

inline
void SaveSMatrix_d(int N, double* dest, const double* Sb) {
	const int n3 = N * 3;
	const int ldd = n3;

	const double* XtX = Sb;
	const double* XtP = Sb + N * 2 * n3;
	const double* PtP = Sb + N * (2 * n3 + 2);
	CopySubMat(N, N, dest, N, XtX, n3);
	CopySubMat(N, N, dest + N * N, N, XtP, n3);
	CopySubMat(N, N, dest + N * N * 2, N, PtP, n3);

}


#ifdef USE_BLAS

/***
* X = {x[0], x[1], ..., x[num_solution-1]}
* X' = X * Cx + R * Cr + P * Cp
* P' = R * Cr + P * Cp
* AX' = AX * Cx + AR * Cr + AP * Cp
* AP' = AR * Cr + AP * Cp
* where when the first update (is_use_p==false), 
* X' = {x[0], x[1], ..., x[num_solution-1]}
* X' = X * Cx + R * Cr
* P' = R * Cr
* AX' = AX * Cx + AR * Cr
* AP' = AR * Cr
* because CG vector P == 0.
* 
* Pay attention. P' is written in buffer of P, while X' is witten in tmp.
* Then user should be copy tmp to buffer of X after this function call.
* 
* When call this function, x, r, p can be regarded as Hx, Hr, Hp
***/
inline
int NextVectors2(int local_size, int num_solution, const double* CxCrCp,
	bool is_use_p,
	std::vector<double*>& x, std::vector<double*>& r, std::vector<double*>& p,
	std::vector<double*>& tmp) {

	using namespace vecmath;
	
	//TMP = R * Cr + P * Cp;
	const double* Cx = CxCrCp;
	const double* Cr = CxCrCp + num_solution;
	const double* Cp = CxCrCp + num_solution * 2;
	const int stride_C = (is_use_p) ? num_solution * 3 : num_solution * 2;
	cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, local_size, num_solution, num_solution, 1.0, r[0], local_size, Cr, stride_C, 0.0, tmp[0], local_size);
	if (is_use_p) {
		cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, local_size, num_solution, num_solution, 1.0, p[0], local_size, Cp, stride_C, 1.0, tmp[0], local_size);
	}

	//P_next = TMP;
	for (int k = 0; k < num_solution; ++k) {
		Copy(p[k], tmp[k], local_size);
	}

	//TMP = TMP + X * Cx;
	cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, local_size, num_solution, num_solution, 1.0, x[0], local_size, Cx, stride_C, 1.0, tmp[0], local_size);


	int num_gemm_call = is_use_p ? 3 : 2;
	return num_gemm_call;

}

inline
int NextVectors(int local_size, int num_solution, const double* CxCrCp,
    bool is_use_p,
    std::vector<double*>& x, std::vector<double*>& r, std::vector<double*>& p,
    std::vector<double*>& tmp) {

    using namespace vecmath;

    int res = NextVectors2(local_size, num_solution, CxCrCp, is_use_p, x, r, p, tmp);

    //X_next = TMP;
    for (int k = 0; k < num_solution; ++k) {
        Copy(x[k], tmp[k], local_size);
    }
    return res;
}
#else

/***
* for the first update because CG vector p == 0,
*			X = {x[0], x[1], ..., x[num_solution-1]}
*			X = X * Cx + R * Cr
*			P = R * Cr
*			AX = AX * Cx + AR * Cr
*			AP = AR * Cr
***/
inline
int NextVectors_first(int local_size, int num_solution, const double* CxCrCp,
	std::vector<double*>& x, std::vector<double*>& r, std::vector<double*>& p,
	std::vector<double*>& Ax, std::vector<double*>& Ar, std::vector<double*>& Ap,
	std::vector<double*>& tmp) {

	using namespace vecmath;
	const int n2 = num_solution * 2;

	//P_next = R * Cr
	for (int k = 0; k < num_solution; ++k) {
		SetZero(p[k], local_size);
		const double* cr = CxCrCp + k * n2 + num_solution;
		for (int j = 0; j < num_solution; ++j) {
			AddV(p[k], r[j], cr[j], local_size);
		}
	}

	//auto& tmp = r;//rはこの時点で使わないので作業領域にする//
	//TMP = X * Cx + P_next;
	for (int k = 0; k < num_solution; ++k) {
		Copy(tmp[k], p[k], local_size);
		const double* cx = CxCrCp + k * n2;
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], x[j], cx[j], local_size);
		}
	}

	//X_next = TMP				
	for (int k = 0; k < num_solution; ++k) {
		Copy(x[k], tmp[k], local_size);
	}

	//AP_next = AR * Cr
	for (int k = 0; k < num_solution; ++k) {
		SetZero(Ap[k], local_size);
		const double* cr = CxCrCp + k * n2 + num_solution;
		for (int j = 0; j < num_solution; ++j) {
			AddV(Ap[k], Ar[j], cr[j], local_size);
		}
	}

	//auto& tmp = r;//rはこの時点で使わないので作業領域にする//
	//TMP = AX * Cx + AP_next;
	for (int k = 0; k < num_solution; ++k) {
		Copy(tmp[k], Ap[k], local_size);
		const double* cx = CxCrCp + k * n2;
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], Ax[j], cx[j], local_size);
		}
	}

	//AX_next = TMP				
	for (int k = 0; k < num_solution; ++k) {
		Copy(Ax[k], tmp[k], local_size);
	}

	return 4;
}


/***
* X = {x[0], x[1], ..., x[num_solution-1]}
* X = X * Cx + R * Cr + P * Cp
* P = R * Cr + P * Cp
* AX = AX * Cx + AR * Cr + AP * Cp
* AP = AR * Cr + AP * Cp
***/
inline 
int NextVectors(int local_size, int num_solution, const double* CxCrCp,
	std::vector<double*>& x, std::vector<double*>& r, std::vector<double*>& p,
	std::vector<double*>& Ax, std::vector<double*>& Ar, std::vector<double*>& Ap,
	std::vector<double*>& tmp) {

	using namespace vecmath;
	const int n3 = num_solution * 3;
#if 1

	//TMP = R * Cr + P * Cp;
	for (int k = 0; k < num_solution; ++k) {
		const double* cx = CxCrCp + k * n3;
		const double* cr = CxCrCp + k * n3 + num_solution;
		const double* cp = CxCrCp + k * n3 + num_solution * 2;
		SetZero(tmp[k], local_size);
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], r[j], cr[j], local_size);
			AddV(tmp[k], p[j], cp[j], local_size);
		}
	}

	//P_next = TMP;
	for (int k = 0; k < num_solution; ++k) {
		Copy(p[k], tmp[k], local_size);
	}

	//TMP = TMP + X * Cx;
	for (int k = 0; k < num_solution; ++k) {
		const double* cx = CxCrCp + k * n3;
		const double* cr = CxCrCp + k * n3 + num_solution;
		const double* cp = CxCrCp + k * n3 + num_solution * 2;
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], x[j], cx[j], local_size);
		}
	}

	//X_next = TMP;
	for (int k = 0; k < num_solution; ++k) {
		Copy(x[k], tmp[k], local_size);
	}


	//TMP = AR * Cr + AP * Cp;
	for (int k = 0; k < num_solution; ++k) {
		const double* cx = CxCrCp + k * n3;
		const double* cr = CxCrCp + k * n3 + num_solution;
		const double* cp = CxCrCp + k * n3 + num_solution * 2;
		SetZero(tmp[k], local_size);
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], Ar[j], cr[j], local_size);
			AddV(tmp[k], Ap[j], cp[j], local_size);
		}
	}

	//AP_next = TMP;
	for (int k = 0; k < num_solution; ++k) {
		Copy(Ap[k], tmp[k], local_size);
	}

	//TMP = TMP + AX * Cx;
	for (int k = 0; k < num_solution; ++k) {
		const double* cx = CxCrCp + k * n3;
		const double* cr = CxCrCp + k * n3 + num_solution;
		const double* cp = CxCrCp + k * n3 + num_solution * 2;
		for (int j = 0; j < num_solution; ++j) {
			AddV(tmp[k], Ax[j], cx[j], local_size);
		}
	}

	//AX_next = TMP;
	for (int k = 0; k < num_solution; ++k) {
		Copy(Ax[k], tmp[k], local_size);
	}

	return 6;
#else
	/*
	X = {x[0], x[1], ..., x[num_solution-1]}
	X = X * Cx + R * Cr + P * Cp
	P = R * Cr + P * Cp
	AX = AX * Cx + AR * Cr + AP * Cp
	AP = AR * Cr + AP * Cp

	//小メモリ化の為, 以下のように変形
	変形前の上記の場合は行列行列積の格納先としてn*Nの一時バッファが必要
	変形後はn*nのCp行列の逆行列を作ることで、行列積の格納先をPやRに指定できる
	P = ( R * (Cr * Cp^{-1}) + P ) * Cp
	X = X * Cx + P
	AP = ( AR * (Cr * Cp^{-1}) + AP) * Cp
	AX = AX * Cx + AP
	*/

	auto& tmp = Ar;
	double* Cp = new double[num_solution * num_solution];
	for (int k = 0; k < num_solution; ++k) {
		const double* cp = S_e_vector + k * n3 + num_solution * 2;
		for (int j = 0; j < num_solution; ++j) {
			Cp[k * num_solution + j] = cp[j];
		}
	}
	double* invCp = new double[num_solution * num_solution];
	InverseM(Cp, num_solution, invCp);//注意:元の行列も破壊される..

	double* Cr_invCp = new double[num_solution * num_solution];
	for (int k = 0; k < num_solution; ++k) {
		const double* cr = S_e_vector + num_solution;
		for (int j = 0; j < num_solution; ++j) {
			double sum = 0.0;
			for (int i = 0; i < num_solution; ++i) {
				sum += cr[i * n3 + j] * invCp[num_solution * k + i];
			}
			Cr_invCp[k * num_solution + j] = sum;
		}
	}

	{
		//P' = ((Cp^{ -1 }*Cr) * R + P)
		for (int k = 0; k < num_solution; ++k) {
			for (int j = 0; j < num_solution; ++j) {
				AddV(p[k], r[j], Cr_invCp[k * num_solution + j], local_size);
			}
		}

		auto& tmp = r;
		//TMP = Cp * P
		for (int k = 0; k < num_solution; ++k) {
			SetZero(tmp[k], local_size);
			const double* cp = S_e_vector + k * n3 + num_solution * 2;
			for (int j = 0; j < num_solution; ++j) {
				AddV(tmp[k], p[j], cp[j], local_size);
			}
		}

		//P_next = TMP				
		for (int k = 0; k < num_solution; ++k) {
			Copy(p[k], tmp[k], local_size);
		}

		//TMP = Cx * X + P_next;
		for (int k = 0; k < num_solution; ++k) {
			Copy(tmp[k], p[k], local_size);
			const double* cx = S_e_vector + k * n3;
			for (int j = 0; j < num_solution; ++j) {
				AddV(tmp[k], x[j], cx[j], local_size);
			}
		}

		//X_next = TMP				
		for (int k = 0; k < num_solution; ++k) {
			Copy(x[k], tmp[k], local_size);
		}
	}

	{

		//AP' = ((Cp^ { -1 }*Cr) * AR + AP)
		for (int k = 0; k < num_solution; ++k) {
			for (int j = 0; j < num_solution; ++j) {
				AddV(Ap[k], Ar[j], Cr_invCp[k * num_solution + j], local_size);
			}
		}

		auto& tmp = Ar;
		//TMP = Cp * AP
		for (int k = 0; k < num_solution; ++k) {
			SetZero(tmp[k], local_size);
			const double* cp = S_e_vector + k * n3 + num_solution * 2;
			for (int j = 0; j < num_solution; ++j) {
				AddV(tmp[k], Ap[j], cp[j], local_size);
			}
		}

		//AP_next = TMP				
		for (int k = 0; k < num_solution; ++k) {
			Copy(Ap[k], tmp[k], local_size);
		}

		//TMP = Cx * AX + AP_next;
		for (int k = 0; k < num_solution; ++k) {
			Copy(tmp[k], Ap[k], local_size);
			const double* cx = S_e_vector + k * n3;
			for (int j = 0; j < num_solution; ++j) {
				AddV(tmp[k], Ax[j], cx[j], local_size);
			}
		}

		//AX_next = TMP				
		for (int k = 0; k < num_solution; ++k) {
			Copy(Ax[k], tmp[k], local_size);
		}
	}

	delete[] Cp;
	delete[] invCp;
	delete[] Cr_invCp;
#endif

}
#endif

/*
固有値問題を解くLOBPCG

問題点、iter_max==1でも前回の履歴からr,p,Ar,Apを継続させるべき

*/
template <class OperationA, class WATCH>
inline
void Eigen_d_multi_mpi(const GridRangeMPI& l_grid, const double dVol, const int num_solution, const int iter_max,
	double* eigen_values, double* eigen_vectors, double* keep_P, double* work, 
	double* keep_S_matrix, int SCF_step, 
#ifdef USE_SCALAPACK
	const BlacsGridInfo& blacs_grid,
#endif
	OperationA OpeA, WATCH& watch) {

	using namespace vecmath;

	const int proc_id = GetProcessID(l_grid.mpi_comm);
	const bool is_root = (proc_id == 0);
	const size_t local_size = l_grid.Size3D();

	auto IntervalPointers = [](double* a, size_t N, size_t num_solution) {
		std::vector<double*> pointers(num_solution);
		for (size_t i = 0; i < num_solution; ++i) {
			pointers[i] = a + i * N;
		}
		return pointers;
		};


	auto x = IntervalPointers(eigen_vectors, local_size, num_solution);
	auto r = IntervalPointers(work, local_size, num_solution);
	auto p = IntervalPointers(keep_P, local_size, num_solution);
	auto Ax = IntervalPointers(work + local_size * num_solution, local_size, num_solution);
	auto Ar = IntervalPointers(work + 2 * local_size * num_solution, local_size, num_solution);
	auto Ap = IntervalPointers(work + 3 * local_size * num_solution, local_size, num_solution);
	auto tmpM = IntervalPointers(work + 4 * local_size * num_solution, local_size, num_solution);

	//std::vector<double> ei;

	const int n3 = 3 * num_solution;
	const int nn9 = (3 * num_solution) * (3 * num_solution);
	double* Sa = new double[nn9 * 4];
	double* Sb = Sa + nn9;
	double* red_Sa = Sa + nn9*2;
	double* red_Sb = Sa + nn9*3;
	SetZero(Sa, nn9 * 4);
	const bool is_first_time = (SCF_step == 0);
	bool is_loaded_S_matrix = false;
	constexpr int S_MAT_REST_LIMIT = 10;//S行列はロードだけだと数値誤差が積もるので定期的に更新//
#ifdef S_MATRIX_RELOAD
	//数値誤差が積もって発散する//
	if ((keep_S_matrix != nullptr) && (!is_first_time) && (SCF_step % S_MAT_REST_LIMIT!=0)) {
		LoadSMatrix_d(num_solution, Sb, keep_S_matrix);
		is_loaded_S_matrix = true;		
	}
#endif

	
	double* S_e_value = new double[(3 * num_solution)];
	double* S_e_vector = new double[nn9];

	const double limit = 1.0e-10;

	double* l_norms = new double[num_solution * 6];
	double* l_norms_p = l_norms + num_solution;
	double* l_norms_r = l_norms + num_solution*2;
	double* sum_norms = l_norms + num_solution * 3;
	double* sum_norms_p = l_norms + num_solution *4;
	double* sum_norms_r = l_norms + num_solution * 5;

#ifdef  LOBPCG_DEBUG_PRINT
	if (is_root) {
		printf("Eigen solver with LOBPCG_d_multi_mpi\n");
	}
#endif

	for (int k = 0; k < num_solution; ++k) {
		vecmath::MulC(x[k], sqrt(dVol), local_size);
	}
	

	//calculte initial redidual r//
	//Because Hamiltonian operator A was changed by changing electronic density rho, //
	// Ax and Ap should be re-calculated//
#ifdef OPERATION_BUNDLE
	OpeA(Ax[0], x[0], tmpM[0]);
	OpeA(Ap[0], p[0], tmpM[0]);
#else
	for (int k = 0; k < num_solution; ++k) {		
		OpeA(Ax[k], x[k]); // calculate Ax from x 	
		OpeA(Ap[k], p[k]);
	}
#endif

	bool is_large_difference = false;
	double*& l_ei = l_norms;
	double*& ei = eigen_values;
	for (int k = 0; k < num_solution; ++k) {
		l_ei[k] = InnerProd(x[k], Ax[k], local_size);
	}
	watch.Record(10);
	MPI_Allreduce(l_ei, ei, num_solution, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
	watch.Record(14);
	
	for (int k = 0; k < num_solution; ++k) {
		double norm = 0.0;
		for (size_t i = 0; i < local_size; ++i) {
			r[k][i] = (Ax[k][i] - ei[k] * x[k][i]);
			norm += r[k][i] * r[k][i];
		}

		l_norms[k] = norm;
	}

	for (int k = 0; k < num_solution; ++k) {
		if (is_first_time) {
			SetZero(p[k], local_size);
			SetZero(Ap[k], local_size);
		}
	}

	if (iter_max < 1) {
		//iterationしないのでnormalizeを元に戻して終了//
		for (int k = 0; k < num_solution; ++k) {
			vecmath::MulC(x[k], 1.0 / sqrt(dVol), local_size);
		}
		return;
	}

	watch.Record(10);

//main loop of LOBPCG

	int iter;
	for (iter = 0; iter < iter_max; ++iter) {

#ifdef OPERATION_BUNDLE
		OpeA(Ar[0], r[0], tmpM[0]);
#else
		for (int k = 0; k < num_solution; ++k) {
			OpeA(Ar[k], r[k]);
		}
#endif

		bool required_reduce_H_S = true;

		int num_gemm1_call = 0;
#ifdef USE_BLAS
#ifdef SELF_TRANSPOSE
		if (iter == 0) {
			//MakeMatrix_d(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap);
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, tmpM[0], is_loaded_S_matrix, false, false);
		} else if ((iter % S_MAT_REST_LIMIT == 0) || is_large_difference) {
			//数値誤差による発散を防ぐため定期的に再計算//
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, tmpM[0], false, false, false);
			is_large_difference = false;
		} else {
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, tmpM[0], true, true, true);
			required_reduce_H_S = false;
	}
#else
		if (iter == 0) {
			//MakeMatrix_d(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap);
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, is_loaded_S_matrix, false, false);
		} else if ((iter % S_MAT_REST_LIMIT == 0) || is_large_difference) {
			//数値誤差による発散を防ぐため定期的に再計算//
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, false, false, false);
			is_large_difference = false;
		} else {
			num_gemm1_call = MakeMatrix_d_blas(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap, true, true, true);
			required_reduce_H_S = false;
		}
#endif
#else
		num_gemm1_call = MakeMatrix_d(local_size, num_solution, Sa, Sb, x, r, p, Ax, Ar, Ap);
#endif
		watch.Record(17, num_gemm1_call);


		//functions to compress H matrix into the empty region of S matrix and to shurink the size of MPI_Allreduce//
		const int N = num_solution;
		const int n2 = num_solution * 2;
		auto Compress_S_H = [&]() {
			const auto* XtHX = Sa;
			const auto* XtHR = Sa + N * n3;
			auto* dstPtR = Sb + N * (n3 + 2);
			auto* dstRtX = Sb + N;
			CopySubMat(N, N, dstPtR, n3, XtHX, n3);
			CopySubMat(N, n2, dstRtX, n3, XtHR, n3);

			};
		auto Expand_S_H = [&]() {
			//repair S matrix//
			auto* dstXtHX = red_Sa;
			auto* dstXtHR = red_Sa + N * n3;
			const auto* PtR = red_Sb + N * (n3 + 2);
			const auto* RtX = red_Sb + N;
			CopySubMat(N, N, dstXtHX, n3, PtR, n3);
			CopySubMat(N, n2, dstXtHR, n3, RtX, n3);

	};


#ifdef CHECK_NEXT_VECTOR
        const bool is_use_p = !((is_first_time && (iter == 0)) || is_large_difference);
#else
		const bool is_use_p = !(is_first_time && (iter == 0));
#endif

		if (!is_use_p) {

			Compress_S_H();
			watch.Record(10);
#ifdef USE_SCALAPACK
			MPI_Allreduce(Sb, red_Sb, N * N * 6, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
#else
			MPI_Reduce(Sb, red_Sb, N* N * 6, MPI_DOUBLE, MPI_SUM, 0, l_grid.mpi_comm);
#endif
			//Expand_S_H();
			watch.Record(14);


			//初回はp=0のため、3n x 3n領域を2n x 2n行列に縮小//
			// 通信ではred_Sbのみを使ったので、red_Sa(9nn領域中の8nn領域)
			//3x3領域を2x2領域に見せるためにとして,初回はPtRからPtPまでの4blockを利用する
			auto* Sa2 = red_Sa;
			auto* Sb2 = Sa2 + n2 * n2;

			CopySubMat(N, n2, Sa2 + N * n2, n2, red_Sb + N, n3);
			CopySubMat(N, N, Sa2, n2, red_Sb + N * (n3 + 2), n3);
			CopySubMat(N, n2, Sb2 + N * n2, n2, red_Sb + N * n3, n3);
			CopySubMat(N, N, Sb2, n2, red_Sb, n3);


			{//store reduced H and S matrix
				CopySubMat(N, N, Sa, n3, red_Sb + N * (n3 + 2), n3);
				CopySubMat(N, n2, Sa + N * n3, n3, red_Sb + N, n3);
				CopySubMat(N, N, Sb, n3, red_Sb, n3);
				CopySubMat(N, n2, Sb + N * n3, n3, red_Sb + N * n3, n3);
			}

			watch.Record(10);

#ifdef USE_SCALAPACK
			int info = lapack_PDSYGVX_split(Sa2, Sb2, &(S_e_value[0]), &(S_e_vector[0]), 2 * num_solution, 1, 2 * num_solution, l_grid.mpi_comm, blacs_grid);
#else
			if (is_root) {
				int info = lapack_DSYGVX(Sa2, Sb2, &(S_e_value[0]), &(S_e_vector[0]), 2 * num_solution);
				//int info = lapack_DSYGVX_range(Sa2, Sb2, &(S_e_value[0]), &(S_e_vector[0]), 2 * num_solution, 1, num_solution);
			}
#endif
			watch.Record(15);


			MPI_Bcast(S_e_value, num_solution, MPI_DOUBLE, 0, l_grid.mpi_comm);
			MPI_Bcast(S_e_vector, num_solution * n2, MPI_DOUBLE, 0, l_grid.mpi_comm);
			watch.Record(14);
			//const int min_id = (S_e_value[0] < S_e_value[1]) ? 0 : 1;
			//固有値の小さい順に並んでいるもの考えてよい//


		} else {//(is_use_p==true)//


			auto StoreReducedMatrix33 = [](int N, auto* Sb, const auto* red_Sb) {
				auto n2 = N * 2;
				auto n3 = N * 3;

				auto* XtX = Sb;
				auto* XtR = Sb + N * n3;
				auto* XtP = Sb + N * 2 * n3;
				const auto* red_XtX = red_Sb;
				const auto* red_XtR = red_Sb + N * n3;
				const auto* red_XtP = red_Sb + N * 2 * n3;

				CopySubMat(N, N, XtX, n3, red_XtX, n3);
				CopySubMat(N, n2, XtR, n3, red_XtR, n3);
				CopySubMat(N, n3, XtP, n3, red_XtP, n3);;
				};
			if (required_reduce_H_S) {
				Compress_S_H();
				watch.Record(10);
#ifdef USE_SCALAPACK
				MPI_Allreduce(Sa + N * n3 * 2, red_Sa + N * n3 * 2, (N * N) * 12, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
#else
				MPI_Reduce(Sa + N * n3 * 2, red_Sa + N * n3 * 2, (N * N) * 12, MPI_DOUBLE, MPI_SUM, 0, l_grid.mpi_comm);
#endif
				watch.Record(14);
				Expand_S_H();

				StoreReducedMatrix33(num_solution, Sa, red_Sa);
				StoreReducedMatrix33(num_solution, Sb, red_Sb);
				

			} else {
				//この場合に通信するのは,XtHR,RtHR,RtHP,RtRの4つ//
				//ただしDIRECT_S_MATRIX_XR_RPが未定義の場合はXtR,RtPも通信が必要//

				const size_t offset_XtR = N * n3;
				const size_t offset_RtP = N * (2 * n3 + 1);
				const size_t offset_PtR = N * (n3 + 2);

				//reduce XtHR,RtHR,RtHP//
				CopySubMat(N, N, Sa + offset_PtR, n3, Sa + offset_RtP, n3);
				watch.Record(10);
				MPI_Allreduce(Sa + offset_XtR, red_Sa + offset_XtR, (N * N) * 3, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
				watch.Record(14);
				auto* RtHP2 = red_Sa + N * (2 * n3 + 1);
				auto* PtHR2 = red_Sa + N * (n3 + 2);
				CopySubMat(N, N, red_Sa + offset_RtP, n3, red_Sa + offset_PtR, n3);

				//store for direct calculation of matrix//
				CopySubMat(N, n2, Sa + offset_XtR, n3, red_Sa + offset_XtR, n3);
				CopySubMat(N, N, Sa + offset_RtP, n3, red_Sa + offset_RtP, n3);

				//load from direct calculated matrix//
				const size_t offset_XtP = N * 2 * n3;
				const size_t offset_PtP = N * (2 * n3 + 2);
				CopySubMat(N, N, red_Sa, n3, Sa, n3);
				CopySubMat(N, N, red_Sa + offset_XtP, n3, Sa + offset_XtP, n3);
				CopySubMat(N, N, red_Sa + offset_PtP, n3, Sa + offset_PtP, n3);

#ifdef DIRECT_S_MATRIX_XR_RP
				//transfer only RtR, XtR, RtP //
				const size_t offset_RtR = N * (n3 + 1);
				
				CopySubMat(N, N, red_Sb, N, Sb + offset_RtR, n3);
				watch.Record(10);
				MPI_Allreduce(red_Sb, red_Sb + N * N, (N * N) * 1, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
				watch.Record(15);
				
				CopySubMat(N, N, red_Sb + offset_RtR, n3, red_Sb + N * N, N);

				//store for direct calculation of matrix//
				CopySubMat(N, N, Sb + offset_RtR, n3, red_Sb + N * N, N);

				//load from direct calculated matrix//
				CopySubMat(N, N, red_Sb + offset_XtR, n3, Sb + offset_XtR, n3);
				CopySubMat(N, N, red_Sb + offset_RtP, n3, Sb + offset_RtP, n3);

#else
				//transfer RtR //
				auto* RtP = Sb + N * (2 * n3 + 1);
				auto* PtR = Sb + N * (n3 + 2);
				CopySubMat(N, N, PtR, n3, RtP, n3);
				watch.Record(10);
				MPI_Allreduce(Sb + N * n33n, red_Sb + N * n3, (N * N) * 3, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
				watch.Record(14);
				auto* RtP2 = red_Sb + N * (2 * n3 + 1);
				auto* PtR2 = red_Sb + N * (n3 + 2);
				CopySubMat(N, N, RtP2, n3, PtR2, n3);

				//store for direct calculation of matrix//
				CopySubMat(N, N * 2, Sb + N * n3, n3, red_Sb + N * n3, n3);
				CopySubMat(N, N, RtP, n3, RtP2, n3);
#endif

				//load from direct calculated matrix//
				CopySubMat(N, N, red_Sb, n3, Sb, n3);
				CopySubMat(N, N, red_Sb + offset_XtP, n3, Sb + offset_XtP, n3);
				CopySubMat(N, N, red_Sb + offset_PtP, n3, Sb + offset_PtP, n3);

				
			}

			watch.Record(10);
#ifdef USE_SCALAPACK
			int info = lapack_PDSYGVX_split(&(red_Sa[0]), &(red_Sb[0]), &(S_e_value[0]), &(S_e_vector[0]), 3 * num_solution, 1, 3 * num_solution, l_grid.mpi_comm, blacs_grid);
#else
			if (is_root) {
				int info = lapack_DSYGVX(&(red_Sa[0]), &(red_Sb[0]), &(S_e_value[0]), &(S_e_vector[0]), 3 * num_solution);
			}
#endif
			watch.Record(15);


			MPI_Bcast(S_e_value, num_solution, MPI_DOUBLE, 0, l_grid.mpi_comm);
			MPI_Bcast(S_e_vector, num_solution * n3, MPI_DOUBLE, 0, l_grid.mpi_comm);
			watch.Record(14);
			//固有値の小さい順に並んでいるもの考えてよい//
			//const int min_id = (S_e_value[0] < S_e_value[1]) ? (S_e_value[0] < S_e_value[2]) ? 0 : 2 : (S_e_value[1] < S_e_value[2]) ? 1 : 2;

		}

		const bool is_final_step = (iter + 1 == iter_max);

		/*
		Calculate the next vectors (next states), X, P, HX, HP as follows:
		X = {x[0], x[1], ..., x[num_solution-1]}
		X = X * Cx + R * Cr + P * Cp
		P = R * Cr + P * Cp
		AX = AX * Cx + AR * Cr + AP * Cp
		AP = AR * Cr + AP * Cp
		where Cx,Cr,CP which are solution S_e_vector of eigen value problem
		*/
		
#ifdef CHECK_NEXT_VECTOR
        int num_gemm2_call = NextVectors2(local_size, num_solution, S_e_vector, is_use_p, x, r, p, tmpM);
        watch.Record(16, num_gemm2_call);


        //normalize X and P vector bandles/////////////////////////
        for (int j = 0; j < num_solution; ++j) {
            l_norms[j] = vecmath::Norm(tmpM[j], local_size);
            l_norms_p[j] = vecmath::Norm(p[j], local_size);
        }
        watch.Record(10);

        const int norm_size = num_solution * 2;
        MPI_Allreduce(l_norms, sum_norms, norm_size, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
        watch.Record(14);



#ifdef LOBPCG_D_PRINT_NORM
        //show norm		
        {
            if (is_root) {
                for (int j = 0; j < norm_size; ++j) {
                    printf("[%d]norm[%d] = %g, %g\n", proc_id, j, sum_norms[j], 1.0 / sqrt(sum_norms[j]));
                }
                fflush(stdout);
            }
        }
#endif

        //正しく解けた場合はxがnormalizeされている//
        //これがずれた場合は数値誤差が積もっているのでXをrollbackし、//
        //Escapeするべし(Hを更新して次のSCF-loopで再計算)//
        double max_diff_norm_x = 0.0;
        for (int k = 0; k < num_solution; ++k) {
            double diff = fabs(1.0 - sum_norms[k]);
            if (max_diff_norm_x < diff)max_diff_norm_x = diff;
        }
        uint8_t check_flag = 0;
        if (max_diff_norm_x > LIMIT_D_NORM_X_FOR_RESET_MATRIX) {
            check_flag = 1;
        }

        uint8_t check_flag_sum = 0;
        MPI_Allreduce(&check_flag, &check_flag_sum, 1, MPI_UINT8_T, MPI_BOR, l_grid.mpi_comm);
        is_large_difference = (check_flag_sum == 1);


        if (is_large_difference) {
            if (is_root) {
                printf("LOBPCG numerical stability breaking: | 1 - |psi|^2| = %g > %g\n", max_diff_norm_x, LIMIT_D_NORM_X_FOR_RESET_MATRIX);
                printf("Rollback psi to the previous state, and escape from LOBPCG loop\n");
                fflush(stdout);
            }

            //////////////////////////////////////
            //escape from this loop
            //////////////////////////////////////
            //keep previous X and R, and H and S matrix is completely calculated in next step and clear P//


            //idea copy R to P for next steps//
            for (int k = 0; k < num_solution; ++k) {
                vecmath::Copy(p[k], r[k], local_size);
            }

            //scaling for dVol, where previous X is alearedy normalized to 1 in grid scale//
            const double coef_x = 1.0 / sqrt(dVol);
            for (int j = 0; j < num_solution; ++j) {
                vecmath::MulC(x[j], coef_x, local_size);
            }

            break;

        } else {//(!is_large_difference) 

            //X_next = TMP;
            for (int k = 0; k < num_solution; ++k) {
                vecmath::Copy(x[k], tmpM[k], local_size);
            }

            for (int i = 0; i < num_solution; ++i) {
                ei[i] = S_e_value[i];
            }

            if (!is_final_step) {
                watch.Record(10);
                int num_gemm2_call = NextVectors2(local_size, num_solution, S_e_vector, is_use_p, Ax, Ar, Ap, tmpM);

                //AX_next = TMP;
                for (int k = 0; k < num_solution; ++k) {
                    vecmath::Copy(Ax[k], tmpM[k], local_size);
                }
                watch.Record(16, num_gemm2_call);



                // next R vector//
                for (int j = 0; j < num_solution; ++j) {
                    //double norm = 0.0;
                    for (size_t i = 0; i < local_size; ++i) {
                        r[j][i] = (Ax[j][i] - ei[j] * x[j][i]);
                        //norm += r[j][i] * r[j][i];
                    }
                    //l_norms_r[j] = norm;
                }


                watch.Record(10);
                int num_gemm3_call = 0;
                num_gemm3_call = NextMatrix_d(num_solution, Sa, Sb, S_e_vector, ei, is_use_p, !is_final_step);
                watch.Record(19, num_gemm3_call);

                //normalize XtX ... in H- and S-matrix//
                //ScaleHSMatrix_d(num_solution, Sa, Sb, sum_norms, sum_norms_p, sum_norms_r, !is_final_step);
            } else {// (is_final_step) 

                for (int j = 0; j < num_solution; ++j) {
                    const double coef_x = 1.0 / sqrt(sum_norms[j] * dVol);
                    vecmath::MulC(x[j], coef_x, local_size);
                }
            }
        }


#ifdef LOBPCG_D_PRINT_EIGEN
        if (is_root) {
            printf("LOBPCG iter = %d\n", iter + 1);
            if (is_final_step) {
                for (int i = 0; i < std::min(20, num_solution); ++i) {
                    printf("eigen[%d] = %f\n", i, ei[i]);
                }
            } else {
                for (int i = 0; i < std::min(20, num_solution); ++i) {
                    printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
                }
                /*
                for (int i = std::max(20, num_solution / 2); i < std::min(num_solution / 2 + 20, num_solution); ++i) {
                    printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
                }
                for (int i = std::max(40, num_solution - 20); i < num_solution; ++i) {
                    printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
                }
                */
            }
            fflush(stdout);
        }

#endif

        watch.Record(10);
#else

        int num_gemm2_call = 0;
#ifdef USE_BLAS
		num_gemm2_call = NextVectors(local_size, num_solution, S_e_vector, is_use_p, x, r, p, tmpM);
		if (!is_final_step) {
			num_gemm2_call += NextVectors(local_size, num_solution, S_e_vector, is_use_p, Ax, Ar, Ap, tmpM);
		}		

#else
		if (is_use_p) {
			num_gemm2_call = NextVectors(local_size, num_solution, S_e_vector, x, r, p, Ax, Ar, Ap, tmpM);
		} else {
			num_gemm2_call = NextVectors_first(local_size, num_solution, S_e_vector, x, r, p, Ax, Ar, Ap, tmpM);
		}
		
#endif
		watch.Record(16, num_gemm2_call);



		for (int i = 0; i < num_solution; ++i) {
			ei[i] = S_e_value[i];
		}

		// next R vector//
		if (!is_final_step) {
			for (int j = 0; j < num_solution; ++j) {
				double norm = 0.0;
				for (size_t i = 0; i < local_size; ++i) {
					r[j][i] = (Ax[j][i] - ei[j] * x[j][i]);
					norm += r[j][i] * r[j][i];
				}
				l_norms_r[j] = norm;
			}
		}


		//normalize X and P vector bandles/////////////////////////
		for (int j = 0; j < num_solution; ++j) {
			l_norms[j] = vecmath::Norm(x[j], local_size);
			l_norms_p[j] = vecmath::Norm(p[j], local_size);
		}
		watch.Record(10);

		const int norm_size = is_final_step ? num_solution * 2 : num_solution * 3;
		MPI_Allreduce(l_norms, sum_norms, norm_size, MPI_DOUBLE, MPI_SUM, l_grid.mpi_comm);
		watch.Record(14);

#ifdef LOBPCG_D_PRINT_NORM
		//show norm		
		{
			if (is_root) {
				for (int j = 0; j < norm_size; ++j) {
					printf("[%d]norm[%d] = %g, %g\n", proc_id, j, sum_norms[j], 1.0 / sqrt(sum_norms[j]));
				}
				fflush(stdout);
			}
		}
#endif


		//正しく解けた場合はxがnormalizeされている//
		//これがずれた場合は数値誤差が積もっているのでH,S行列を再計算するべし//
		double max_diff_norm_x = 0.0;
		for (int k = 0; k < num_solution; ++k) {
			double diff = fabs(1.0 - sum_norms[k]);
			if (max_diff_norm_x < diff)max_diff_norm_x = diff;
		}
		if (max_diff_norm_x > 1.0e-4) {
			is_large_difference = true;
		}

		if (is_final_step) {

			for (int j = 0; j < num_solution; ++j) {
				const double coef_x = 1.0 / sqrt(sum_norms[j] * dVol);
				vecmath::MulC(x[j], coef_x, local_size);
			}


		}else{ //!is_final_step

			if (!is_large_difference) {
				watch.Record(10);
				int num_gemm3_call = 0;
				num_gemm3_call = NextMatrix_d(num_solution, Sa, Sb, S_e_vector, ei, is_use_p, !is_final_step);
				watch.Record(19, num_gemm3_call);

				//normalize XtX ... in H- and S-matrix//
				//ScaleHSMatrix_d(num_solution, Sa, Sb, sum_norms, sum_norms_p, sum_norms_r, !is_final_step);
			}
		}


#ifdef LOBPCG_D_PRINT_EIGEN
		if (is_root) {
			printf("LOBPCG iter = %d\n", iter + 1);
			if (is_final_step) {
				for (int i = 0; i < std::min(20, num_solution); ++i) {
					printf("eigen[%d] = %f\n", i, ei[i]);
				}
			} else {
				for (int i = 0; i < std::min(20, num_solution); ++i) {
					printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
				}
				for (int i = std::max(20, num_solution/2); i < std::min(num_solution / 2 + 20, num_solution); ++i) {
					printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
				}
				for (int i = std::max(40, num_solution -20); i < num_solution; ++i) {
					printf("eigen[%d] = %f, %f\n", i, ei[i], S_e_value[i]);
				}
			}
			fflush(stdout);
		}

#endif

		watch.Record( 10);
#endif
	}

	
	if (is_root) {
		printf("LOBPCG iteration = %d:\n", iter); fflush(stdout);
	}
	////////////////////////////End of loop of Lanczos to create Symmetric Tridiagonal T// 

#ifdef S_MATRIX_RELOAD

	if ((keep_S_matrix != nullptr)) {
		int num_gemm3_call = 0;
		num_gemm3_call = NextMatrix_d(num_solution, Sa, Sb, S_e_vector, S_e_value, (iter_max > 1), false);
		watch.Record(19, num_gemm3_call);

		//normalize XtX ... in H- and S-matrix//
		ScaleHSMatrix_d(num_solution, Sa, Sb, sum_norms, sum_norms_p, sum_norms_r, false);
		SaveSMatrix_d(num_solution, keep_S_matrix, Sb);
	}
#endif

	delete[] l_norms;
	delete[] Sa;
	delete[] S_e_value;
	delete[] S_e_vector;

	watch.Record( 10);
}

inline
size_t WorkSize_d_multi_mpi(int local_size, int num_solution) {
	return 5 * local_size * num_solution;
}

}//namespace LOBPCG

#endif
